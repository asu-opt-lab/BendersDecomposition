var documenterSearchIndex = {"docs":
[{"location":"examples/SNIP/","page":"Stochastic Network Interdiction Problem","title":"Stochastic Network Interdiction Problem","text":"EditURL = \"SNIP.jl\"","category":"page"},{"location":"examples/SNIP/#Stochastic-Network-Interdiction-Problem","page":"Stochastic Network Interdiction Problem","title":"Stochastic Network Interdiction Problem","text":"","category":"section"},{"location":"examples/SNIP/#Formulation","page":"Stochastic Network Interdiction Problem","title":"Formulation","text":"","category":"section"},{"location":"examples/SNIP/","page":"Stochastic Network Interdiction Problem","title":"Stochastic Network Interdiction Problem","text":"beginaligned\ntextSNIP quad min  sum_k p_k x_ik \ntextst quad  x_ik = 1  forall k in K \n x_ik - q_kx_jk geq 0  forall a = (ij) in D k in K \n x_ik - r_kx_jk geq 0  forall a = (ij) in A setminus D k in K \n x_ik - r_kx_jk geq -(r_k - q_k)y_ay_k  forall a = (ij) in D k in K \n x geq 0 y in Y\nendaligned","category":"page"},{"location":"examples/SNIP/#Example","page":"Stochastic Network Interdiction Problem","title":"Example","text":"","category":"section"},{"location":"examples/SNIP/","page":"Stochastic Network Interdiction Problem","title":"Stochastic Network Interdiction Problem","text":"using BendersDecomposition\nusing JuMP\nusing CPLEX","category":"page"},{"location":"examples/SNIP/#Let's-solve-this-simple-instance-directly-using-a-solver.","page":"Stochastic Network Interdiction Problem","title":"Let's solve this simple instance directly using a solver.","text":"","category":"section"},{"location":"examples/SNIP/","page":"Stochastic Network Interdiction Problem","title":"Stochastic Network Interdiction Problem","text":"data = readsnipdata(0, 1, 90.0; basedir=joinpath(dirname(dirname(dirname(@DIR))), \"data\", \"SNIP\")) milp = createmilp(data) setoptimizer(milp.model, CPLEX.Optimizer) setoptimizer_attribute(milp.model, MOI.Silent(), false) optimize!(milp.model)","category":"page"},{"location":"examples/SNIP/#Then,-let's-solve-this-problem-using-Benders-decomposition.","page":"Stochastic Network Interdiction Problem","title":"Then, let's solve this problem using Benders decomposition.","text":"","category":"section"},{"location":"examples/SNIP/","page":"Stochastic Network Interdiction Problem","title":"Stochastic Network Interdiction Problem","text":"solver = \"CPLEX\" params = BendersParams(     60.0, # Time limit     0.00001, # Tolerance     solver,     Dict(\"solver\" => solver),     Dict(\"solver\" => solver),     Dict(),     true # verbose )","category":"page"},{"location":"examples/SNIP/#Then,-let's-solve-this-problem-using-Benders-decomposition.-2","page":"Stochastic Network Interdiction Problem","title":"Then, let's solve this problem using Benders decomposition.","text":"","category":"section"},{"location":"examples/SNIP/","page":"Stochastic Network Interdiction Problem","title":"Stochastic Network Interdiction Problem","text":"solver = \"CPLEX\" params = BendersParams(     60.0, # Time limit     0.00001, # Tolerance     solver,     Dict(\"solver\" => solver),     Dict(\"solver\" => solver),     Dict(),     true # verbose ) cutstrategy = ClassicalCut() solutionprocedure = StochasticSequential() runBenders(data, solutionprocedure, cut_strategy, params) #-","category":"page"},{"location":"examples/SNIP/#If-you-want-to-use-callback-methods,-you-can-use-the-following-code:","page":"Stochastic Network Interdiction Problem","title":"If you want to use callback methods, you can use the following code:","text":"","category":"section"},{"location":"examples/SNIP/","page":"Stochastic Network Interdiction Problem","title":"Stochastic Network Interdiction Problem","text":"cutstrategy = ClassicalCut() solutionprocedure = StochasticCallback() runBenders(data, solutionprocedure, cut_strategy, params) #-","category":"page"},{"location":"examples/SNIP/","page":"Stochastic Network Interdiction Problem","title":"Stochastic Network Interdiction Problem","text":"","category":"page"},{"location":"examples/SNIP/","page":"Stochastic Network Interdiction Problem","title":"Stochastic Network Interdiction Problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/MCNDP/","page":"Multi-Commodity Network Design Problem","title":"Multi-Commodity Network Design Problem","text":"EditURL = \"MCNDP.jl\"","category":"page"},{"location":"examples/MCNDP/#Multi-Commodity-Network-Design-Problem","page":"Multi-Commodity Network Design Problem","title":"Multi-Commodity Network Design Problem","text":"","category":"section"},{"location":"examples/MCNDP/","page":"Multi-Commodity Network Design Problem","title":"Multi-Commodity Network Design Problem","text":"Consider this problem:","category":"page"},{"location":"examples/MCNDP/","page":"Multi-Commodity Network Design Problem","title":"Multi-Commodity Network Design Problem","text":"beginaligned\ntextMCNDP quad min  sum_iin Isum_jin Ad_ic_ijx_ij + sum_jin Af_jy_j \ntextst quad  sum_jin A_v^+x_ij - sum_jin A_v^-x_ij = b_iv  forall i in I v in V \n sum_iin Id_i x_ij leq s_jy_j  forall j in A \n x_ij leq y_j  forall i in I j in A \n mathbfx geq mathbf0 mathbfy in Y\nendaligned","category":"page"},{"location":"examples/MCNDP/#Example","page":"Multi-Commodity Network Design Problem","title":"Example","text":"","category":"section"},{"location":"examples/MCNDP/","page":"Multi-Commodity Network Design Problem","title":"Multi-Commodity Network Design Problem","text":"using BendersDecomposition\nusing Gurobi\nusing JuMP","category":"page"},{"location":"examples/MCNDP/","page":"Multi-Commodity Network Design Problem","title":"Multi-Commodity Network Design Problem","text":"Let's solve this simple instance directly using a solver.","category":"page"},{"location":"examples/MCNDP/","page":"Multi-Commodity Network Design Problem","title":"Multi-Commodity Network Design Problem","text":"data = read_mcndp_instance(\"r01.1.dow\"; filepath=joinpath(dirname(dirname(dirname(@__DIR__))), \"data\", \"NDR\"))\nmilp = create_milp(data)\nset_optimizer(milp.model, Gurobi.Optimizer)\nset_optimizer_attribute(milp.model, MOI.Silent(), false)\noptimize!(milp.model)","category":"page"},{"location":"examples/MCNDP/","page":"Multi-Commodity Network Design Problem","title":"Multi-Commodity Network Design Problem","text":"Then, let's solve this problem using Benders decomposition.","category":"page"},{"location":"examples/MCNDP/","page":"Multi-Commodity Network Design Problem","title":"Multi-Commodity Network Design Problem","text":"solver = \"Gurobi\"\nparams = BendersParams(\n    60.0, # Time limit\n    0.00001, # Tolerance\n    solver,\n    Dict(\"solver\" => solver),\n    Dict(\"solver\" => solver, \"InfUnbdInfo\" => 1),\n    Dict(),\n    true # verbose\n)\ncut_strategy = ClassicalCut()\nsolution_procedure = Sequential()\nrun_Benders(data, solution_procedure, cut_strategy, params)","category":"page"},{"location":"examples/MCNDP/","page":"Multi-Commodity Network Design Problem","title":"Multi-Commodity Network Design Problem","text":"If you want to use knapsack cuts, you can use the following code:","category":"page"},{"location":"examples/MCNDP/","page":"Multi-Commodity Network Design Problem","title":"Multi-Commodity Network Design Problem","text":"cut_strategy = KnapsackCut()\nsolution_procedure = Sequential()\nrun_Benders(data, solution_procedure, cut_strategy, params)","category":"page"},{"location":"examples/MCNDP/","page":"Multi-Commodity Network Design Problem","title":"Multi-Commodity Network Design Problem","text":"If you want to use callback methods, you can use the following code:","category":"page"},{"location":"examples/MCNDP/","page":"Multi-Commodity Network Design Problem","title":"Multi-Commodity Network Design Problem","text":"cut_strategy = ClassicalCut()\nsolution_procedure = Callback()\nrun_Benders(data, solution_procedure, cut_strategy, params)","category":"page"},{"location":"examples/MCNDP/","page":"Multi-Commodity Network Design Problem","title":"Multi-Commodity Network Design Problem","text":"","category":"page"},{"location":"examples/MCNDP/","page":"Multi-Commodity Network Design Problem","title":"Multi-Commodity Network Design Problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/intro/","page":"Introduction","title":"Introduction","text":"EditURL = \"intro.jl\"","category":"page"},{"location":"examples/intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"examples/intro/","page":"Introduction","title":"Introduction","text":"In this package, we provide some instances and some cut strategies.","category":"page"},{"location":"examples/intro/","page":"Introduction","title":"Introduction","text":"graph TD\n  A[Instances] --> B[Capacitated Facility Location Problem]\n  A --> C[Uncapacitated Facility Location Problem]\n  A --> D[Stochastic Capacitated Facility Location Problem]\n  A --> E[Multicommodity Capacitated Network Design Problem]\n  A --> F[Stochastic Network Interdiction Problem]\n  B --> G[Classical Cut]\n  C --> G\n  D --> G\n  E --> G\n  F --> G\n  B --> H[Knapsack Cut]\n  C --> H\n  D --> H\n  E --> H","category":"page"},{"location":"examples/intro/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"examples/intro/","page":"Introduction","title":"Introduction","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorial/advanced/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"EditURL = \"advanced.jl\"","category":"page"},{"location":"tutorial/advanced/#Advanced-Tutorial","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"","category":"section"},{"location":"tutorial/advanced/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"For the researchers and industry practitioners, they may need to customize the Benders Decomposition algorithm to solve their own problems. We provide the BendersOracle interface to allow users to customize the modeling, solving and cutting process.","category":"page"},{"location":"tutorial/advanced/#Key-Concepts","page":"Advanced Tutorial","title":"Key Concepts","text":"","category":"section"},{"location":"tutorial/advanced/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"AbstractData: The data structure that stores the problem data. For large-scale problems, it is recommended to use the AbstractData interface to store the problem data. Then the user can use the data to build the model.","category":"page"},{"location":"tutorial/advanced/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"SolutionProcedure: Itertively or callback function to process the solution.","category":"page"},{"location":"tutorial/advanced/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"CutStrategy: The strategy to generate the cuts, such as classical Benders cut, unified Benders cut, etc.","category":"page"},{"location":"tutorial/advanced/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"AbstractMasterProblem: The abstract type for the master problem.","category":"page"},{"location":"tutorial/advanced/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"AbstractSubProblem: The abstract type for the subproblem.","category":"page"},{"location":"tutorial/advanced/#Modeling","page":"Advanced Tutorial","title":"Modeling","text":"","category":"section"},{"location":"tutorial/advanced/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"Unlike algebraic algorithms, Benders decomposition is typically used for large-scale problems. In this approach, researchers do not rely on abstract matrix representations to compute key elements in the solving process. Instead, researchers usually explicitly formulate both the master problem and the subproblem. The partitioning of variables and constraints can vary significantly depending on the application.","category":"page"},{"location":"tutorial/advanced/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"Then the next question is how to build the model. Which information should we use to build the model? Our answer is AbstractData and CutStrategy. For different applications, the AbstractData is different. For the same application, the CutStrategy can be different. We only need to provide the AbstractData and CutStrategy to build the model. So we have two functions to build the model:","category":"page"},{"location":"tutorial/advanced/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"Use create_master_problem(data::AbstractData, cut_strategy::CutStrategy) to build master_problem <: AbstractMasterProblem.\nUse create_sub_problem(data::AbstractData, cut_strategy::CutStrategy) to build sub_problem <: AbstractSubProblem.","category":"page"},{"location":"tutorial/advanced/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"We provide a general standard structure for master problem and subproblem for different applications. General structures:","category":"page"},{"location":"tutorial/advanced/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"struct GeneralMasterProblem <: AbstractMasterProblem\n    model::Model # JuMP model\n    var::Dict # variable dictionary\n    obj_value::Float64 # objective value\n    x_value::Vector{Float64} # integer variables\n    t_value::Union{Float64,Vector{Float64}} # continuous variables\nend","category":"page"},{"location":"tutorial/advanced/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"and","category":"page"},{"location":"tutorial/advanced/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"struct GeneralSubProblem <: AbstractSubProblem\n    model::Model # JuMP model\n    fixed_x_constraints::Vector{ConstraintRef} # fixed integer variables constraints\n    other_constraints::Vector{ConstraintRef} # other constraints\nend","category":"page"},{"location":"tutorial/advanced/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"But if user want to use their own unique model, they can define their own structures and multiple dispatch the create_master_problem and create_sub_problem function.","category":"page"},{"location":"tutorial/advanced/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"For example, the fat knapsack cut method proposed by Fischetti in uncapacitated facility location problem, we don't need to build a traditional subproblem. We define a new structure storing necessary information to represent the subproblem:","category":"page"},{"location":"tutorial/advanced/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"mutable struct KnapsackUFLPSubProblem <: AbstractUFLPSubProblem\n    sorted_cost_demands::Vector{Vector{Float64}}\n    sorted_indices::Vector{Vector{Int}}\n    selected_k::Dict\nend","category":"page"},{"location":"tutorial/advanced/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"If you want to use the Disjunctive Benders Cuts we proposed in our paper, you can use create_dcglp(data::AbstractData, cut_strategy::CutStrategy) to build dcglp <: AbstractDCGLP.","category":"page"},{"location":"tutorial/advanced/#Environment","page":"Advanced Tutorial","title":"Environment","text":"","category":"section"},{"location":"tutorial/advanced/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"Here we introduce a new concept: Environment, borrowed from Reinforcement Learning. The BendersEnv is a structure that stores the modeling information:","category":"page"},{"location":"tutorial/advanced/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"mutable struct BendersEnv\n    master::AbstractMasterProblem\n    sub::Union{AbstractSubProblem, Vector{AbstractSubProblem}} # for deterministic problems, sub is a single subproblem; for stochastic problems, sub is a vector of subproblems\n    dcglp::Union{Nothing, DCGLP}  # Optional component\nend","category":"page"},{"location":"tutorial/advanced/#Solution-Procedure","page":"Advanced Tutorial","title":"Solution Procedure","text":"","category":"section"},{"location":"tutorial/advanced/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"In textbooks, Benders decomposition is typically presented as an iterative algorithm. However, in research applications, the Branch-and-Cut method is often used to obtain the final results. In this approach, researchers leverage callback methods to incorporate lazy constraints, user cuts and heuristic methods, providing flexibility in implementation. This allows for various strategies to enhance the efficiency of the decomposition process.","category":"page"},{"location":"tutorial/advanced/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"In this package, we provide Sequential(), Callback(), StochasticSequential(), StochasticCallback() to solve the problem.","category":"page"},{"location":"tutorial/advanced/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"The corresponding function is solve!(env::BendersEnv, solution_procedure::SolutionProcedure, params::Params).","category":"page"},{"location":"tutorial/advanced/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"For example, the iterative solution procedure is:","category":"page"},{"location":"tutorial/advanced/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"function solve!(env::BendersEnv, ::Sequential, cut_strategy::CutStrategy, params::BendersParams)\n    log = BendersIterationLog()\n    state = BendersState()\n\n    while true\n        state.iteration += 1\n\n        # Solve master problem\n        master_time = @elapsed begin\n            solve_master!(env.master)\n            state.LB = env.master.obj_value\n        end\n        log.master_time += master_time\n\n        # Solve sub problem\n        sub_time = @elapsed begin\n            solve_sub!(env.sub, env.master.x_value)\n            cuts, sub_obj_val = generate_cuts(env, cut_strategy)\n            update_upper_bound_and_gap!(state, env, sub_obj_val)\n        end\n        log.sub_time += sub_time\n\n        # Update state and record information\n        record_iteration!(log, state)\n\n        params.verbose && print_iteration_info(state, log)\n\n        # Check termination criteria\n        is_terminated(state, params, log) && break\n\n        # Generate and add cuts\n        for cut in cuts\n            @constraint(env.master.model, 0 >= cut)\n        end\n    end\nend","category":"page"},{"location":"tutorial/advanced/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"The callback method:","category":"page"},{"location":"tutorial/advanced/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"function solve!(env::BendersEnv, ::Callback, cut_strategy::CutStrategy, params::BendersParams)\n\n    start_time = time()\n    function lazy_callback(cb_data)\n        status = JuMP.callback_node_status(cb_data, env.master.model)\n        if status == MOI.CALLBACK_NODE_STATUS_INTEGER\n            env.master.x_value = JuMP.callback_value.(cb_data, env.master.var[:x])\n            env.master.t_value = JuMP.callback_value.(cb_data, env.master.var[:t])\n\n            solve_sub!(env.sub, env.master.x_value)\n            cuts, sub_obj_value = generate_cuts(env, cut_strategy)\n            add_cuts!(env, cuts, sub_obj_value, cb_data)\n        end\n    end\n\n    function user_cut_callback(cb_data)\n        ... # user cut callback\n    end\n\n    # Use the closure callbacks\n    set_attribute(env.master.model, MOI.LazyConstraintCallback(), lazy_callback)\n    set_attribute(env.master.model, MOI.UserCutCallback(), user_cut_callback)\n    MOI.set(env.master.model, MOI.RelativeGapTolerance(), params.gap_tolerance)\n    set_time_limit_sec(env.master.model, params.time_limit)\n    set_optimizer_attribute(env.master.model, MOI.Silent(), false)\n    JuMP.optimize!(env.master.model)\nend","category":"page"},{"location":"tutorial/advanced/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"The user can customize the solution procedure by defining a new SolutionProcedure and multiple dispatch the solve! function.","category":"page"},{"location":"tutorial/advanced/#Cut-Strategy","page":"Advanced Tutorial","title":"Cut Strategy","text":"","category":"section"},{"location":"tutorial/advanced/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"The cut strategy is the key to the Benders decomposition algorithm. The cut strategy determines how to generate the cuts.","category":"page"},{"location":"tutorial/advanced/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"We provide some general cut strategies for different applications, such as classical cut, unified cut, disjunctive cut, etc.","category":"page"},{"location":"tutorial/advanced/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"The key function is generate_cut(env::BendersEnv, cut_strategy::CutStrategy), which generates the cuts and add them to the model.","category":"page"},{"location":"tutorial/advanced/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"For example, the classical cut is:","category":"page"},{"location":"tutorial/advanced/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"function generate_cuts(env::BendersEnv, ::ClassicalCut)\n    (coefficients_t, coefficients_x, constant_term), sub_obj_val = generate_cut_coefficients(env.sub, env.master.x_value, ClassicalCut())\n\n    cut = @expression(env.master.model,\n        constant_term + dot(coefficients_x, env.master.var[:x]) + coefficients_t * env.master.var[:t])\n\n    return cut, sub_obj_val\nend","category":"page"},{"location":"tutorial/advanced/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"If you want to use the fat knapsack cut:","category":"page"},{"location":"tutorial/advanced/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"function generate_cuts(env::BendersEnv, cut_strategy::Union{FatKnapsackCut, SlimKnapsackCut})\n\n    # return vector\n    critical_pairs, obj_values = generate_cut_coefficients(env.sub, env.master.x_value, cut_strategy)\n\n    cuts = Vector{Any}(undef, length(critical_pairs))\n    for (index, critical_item) in critical_pairs\n        cuts[index] = build_cut(env.master, env.sub, (index, critical_item), cut_strategy)\n    end\n\n    return cuts, obj_values\nend","category":"page"},{"location":"tutorial/advanced/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"","category":"page"},{"location":"tutorial/advanced/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/CFLP/","page":"Capacitated Facility Location Problem","title":"Capacitated Facility Location Problem","text":"EditURL = \"CFLP.jl\"","category":"page"},{"location":"examples/CFLP/#Capacitated-Facility-Location-Problem","page":"Capacitated Facility Location Problem","title":"Capacitated Facility Location Problem","text":"","category":"section"},{"location":"examples/CFLP/#Formulation","page":"Capacitated Facility Location Problem","title":"Formulation","text":"","category":"section"},{"location":"examples/CFLP/","page":"Capacitated Facility Location Problem","title":"Capacitated Facility Location Problem","text":"Consider this problem:","category":"page"},{"location":"examples/CFLP/","page":"Capacitated Facility Location Problem","title":"Capacitated Facility Location Problem","text":"beginaligned\nmin   sum_i in If_i x_i + sum_i in Isum_j in J c_ijd_iy_ij \ntextst   sum_i in I y_ij geq 1  forall j in J \n sum_j in J y_ij leq u_ix_i  forall i in I \n y_ij leq x_i  forall i in I j in J \n x in mathbb B^I y in mathbbR_+^I times J\nendaligned","category":"page"},{"location":"examples/CFLP/#Example","page":"Capacitated Facility Location Problem","title":"Example","text":"","category":"section"},{"location":"examples/CFLP/","page":"Capacitated Facility Location Problem","title":"Capacitated Facility Location Problem","text":"using BendersDecomposition\nusing CPLEX\nusing JuMP","category":"page"},{"location":"examples/CFLP/","page":"Capacitated Facility Location Problem","title":"Capacitated Facility Location Problem","text":"Let's solve this simple instance directly using a solver.","category":"page"},{"location":"examples/CFLP/","page":"Capacitated Facility Location Problem","title":"Capacitated Facility Location Problem","text":"data = read_cflp_benchmark_data(\"p1\"; filepath=joinpath(dirname(dirname(dirname(@__DIR__))), \"data\", \"locssall\"))\nmilp = create_milp(data)\nset_optimizer(milp.model, CPLEX.Optimizer)\nset_optimizer_attribute(milp.model, MOI.Silent(), false)\noptimize!(milp.model)","category":"page"},{"location":"examples/CFLP/","page":"Capacitated Facility Location Problem","title":"Capacitated Facility Location Problem","text":"Then, let's solve this problem using Benders decomposition.","category":"page"},{"location":"examples/CFLP/","page":"Capacitated Facility Location Problem","title":"Capacitated Facility Location Problem","text":"solver = \"CPLEX\"\nparams = BendersParams(\n    60.0, # Time limit\n    0.00001, # Tolerance\n    solver,\n    Dict(\"solver\" => solver),\n    Dict(\"solver\" => solver),\n    Dict(),\n    true # verbose\n)\ncut_strategy = ClassicalCut()\nsolution_procedure = Sequential()\nrun_Benders(data, solution_procedure, cut_strategy, params)","category":"page"},{"location":"examples/CFLP/","page":"Capacitated Facility Location Problem","title":"Capacitated Facility Location Problem","text":"If you want to use knapsack cuts, you can use the following code:","category":"page"},{"location":"examples/CFLP/","page":"Capacitated Facility Location Problem","title":"Capacitated Facility Location Problem","text":"cut_strategy = KnapsackCut()\nsolution_procedure = Sequential()\nrun_Benders(data, solution_procedure, cut_strategy, params)","category":"page"},{"location":"examples/CFLP/","page":"Capacitated Facility Location Problem","title":"Capacitated Facility Location Problem","text":"If you want to use callback methods, you can use the following code:","category":"page"},{"location":"examples/CFLP/","page":"Capacitated Facility Location Problem","title":"Capacitated Facility Location Problem","text":"cut_strategy = ClassicalCut()\nsolution_procedure = Callback()\nrun_Benders(data, solution_procedure, cut_strategy, params)","category":"page"},{"location":"examples/CFLP/","page":"Capacitated Facility Location Problem","title":"Capacitated Facility Location Problem","text":"","category":"page"},{"location":"examples/CFLP/","page":"Capacitated Facility Location Problem","title":"Capacitated Facility Location Problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorial/beginner/","page":"Beginner Tutorial","title":"Beginner Tutorial","text":"EditURL = \"beginner.jl\"","category":"page"},{"location":"tutorial/beginner/#Beginner-Tutorial","page":"Beginner Tutorial","title":"Beginner Tutorial","text":"","category":"section"},{"location":"tutorial/beginner/#Why-should-you-use-BendersDecomposition.jl?","page":"Beginner Tutorial","title":"Why should you use BendersDecomposition.jl?","text":"","category":"section"},{"location":"tutorial/beginner/","page":"Beginner Tutorial","title":"Beginner Tutorial","text":"For the beginners, BendersDecomposition.jl is a good choice for solving optimization problems using Benders Decomposition. It provides an easy-to-use interface for building the model and directly solve the problem using some classical algorithms. That means you can solve your problem without worrying about the details of the algorithm.","category":"page"},{"location":"tutorial/beginner/","page":"Beginner Tutorial","title":"Beginner Tutorial","text":"We provide some classical algorithms for solving the Benders Decomposition, such as the classical Benders cuts [paper link], the unified Benders cuts [paper link], the Disjunctive Benders cuts [paper link], etc.","category":"page"},{"location":"tutorial/beginner/","page":"Beginner Tutorial","title":"Beginner Tutorial","text":"Also, for beginners, we provide both iterative and branch-and-cut algorithms for solving the problems.","category":"page"},{"location":"tutorial/beginner/#@benders_decomposition","page":"Beginner Tutorial","title":"@benders_decomposition","text":"","category":"section"},{"location":"tutorial/beginner/","page":"Beginner Tutorial","title":"Beginner Tutorial","text":"The @benders_decomposition macro is the core of BendersDecomposition.jl. It is used to build the model and solve the problem.","category":"page"},{"location":"tutorial/beginner/#Simple-Example","page":"Beginner Tutorial","title":"Simple Example","text":"","category":"section"},{"location":"tutorial/beginner/","page":"Beginner Tutorial","title":"Beginner Tutorial","text":"Here is an example of solving a simple CFLP problem using BendersDecomposition.jl.","category":"page"},{"location":"tutorial/beginner/","page":"Beginner Tutorial","title":"Beginner Tutorial","text":"using BendersDecomposition\nusing JuMP\n\n@benders_decomposition standard_env begin\n    @master_problem begin\n        @varible\n        @objective\n        @constraint\n    end\n    @sub_problem begin\n        @variable\n        @objective\n        @constraint\n        @constraint\n    end\nend\nsolve!(standard_env)","category":"page"},{"location":"tutorial/beginner/","page":"Beginner Tutorial","title":"Beginner Tutorial","text":"","category":"page"},{"location":"tutorial/beginner/","page":"Beginner Tutorial","title":"Beginner Tutorial","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/SCFLP/","page":"Stochastic Capacitated Facility Location Problem","title":"Stochastic Capacitated Facility Location Problem","text":"EditURL = \"SCFLP.jl\"","category":"page"},{"location":"examples/SCFLP/#Stochastic-Capacitated-Facility-Location-Problem","page":"Stochastic Capacitated Facility Location Problem","title":"Stochastic Capacitated Facility Location Problem","text":"","category":"section"},{"location":"examples/SCFLP/#Formulation","page":"Stochastic Capacitated Facility Location Problem","title":"Formulation","text":"","category":"section"},{"location":"examples/SCFLP/","page":"Stochastic Capacitated Facility Location Problem","title":"Stochastic Capacitated Facility Location Problem","text":"Consider the SAA problem:","category":"page"},{"location":"examples/SCFLP/","page":"Stochastic Capacitated Facility Location Problem","title":"Stochastic Capacitated Facility Location Problem","text":"beginaligned\nmin   sum_i in If_i x_i + frac1K sum_k in K sum_i in Isum_j in J c_ijd_iy_ijk \ntextst   sum_i in I y_ijk geq 1  forall j in J k in K \n sum_j in J y_ijk leq u_ix_i  forall i in I k in K \n y_ijk leq x_i  forall i in I j in J k in K \n x in mathbb B^I y in mathbbR_+^I times J times K\nendaligned","category":"page"},{"location":"examples/SCFLP/#Example","page":"Stochastic Capacitated Facility Location Problem","title":"Example","text":"","category":"section"},{"location":"examples/SCFLP/","page":"Stochastic Capacitated Facility Location Problem","title":"Stochastic Capacitated Facility Location Problem","text":"using BendersDecomposition\nusing CPLEX\nusing JuMP","category":"page"},{"location":"examples/SCFLP/","page":"Stochastic Capacitated Facility Location Problem","title":"Stochastic Capacitated Facility Location Problem","text":"Let's solve this simple instance directly using a solver.","category":"page"},{"location":"examples/SCFLP/","page":"Stochastic Capacitated Facility Location Problem","title":"Stochastic Capacitated Facility Location Problem","text":"data = read_stochastic_capacited_facility_location_problem(\"f10-c10-s25-r3-1\"; filepath=joinpath(dirname(dirname(dirname(@__DIR__))), \"data\", \"SCFLP\"))\nmilp = create_milp(data)\nset_optimizer(milp.model, CPLEX.Optimizer)\nset_optimizer_attribute(milp.model, MOI.Silent(), false)\noptimize!(milp.model)","category":"page"},{"location":"examples/SCFLP/","page":"Stochastic Capacitated Facility Location Problem","title":"Stochastic Capacitated Facility Location Problem","text":"Then, let's solve this problem using Benders decomposition.","category":"page"},{"location":"examples/SCFLP/","page":"Stochastic Capacitated Facility Location Problem","title":"Stochastic Capacitated Facility Location Problem","text":"solver = \"CPLEX\"\nparams = BendersParams(\n    60.0, # Time limit\n    0.00001, # Tolerance\n    solver,\n    Dict(\"solver\" => solver),\n    Dict(\"solver\" => solver),\n    Dict(),\n    true # verbose\n)\ncut_strategy = ClassicalCut()\nsolution_procedure = StochasticSequential()\nrun_Benders(data, solution_procedure, cut_strategy, params)","category":"page"},{"location":"examples/SCFLP/","page":"Stochastic Capacitated Facility Location Problem","title":"Stochastic Capacitated Facility Location Problem","text":"If you want to use knapsack cuts, you can use the following code:","category":"page"},{"location":"examples/SCFLP/","page":"Stochastic Capacitated Facility Location Problem","title":"Stochastic Capacitated Facility Location Problem","text":"cut_strategy = KnapsackCut()\nsolution_procedure = StochasticSequential()\nrun_Benders(data, solution_procedure, cut_strategy, params)","category":"page"},{"location":"examples/SCFLP/","page":"Stochastic Capacitated Facility Location Problem","title":"Stochastic Capacitated Facility Location Problem","text":"If you want to use callback methods, you can use the following code:","category":"page"},{"location":"examples/SCFLP/","page":"Stochastic Capacitated Facility Location Problem","title":"Stochastic Capacitated Facility Location Problem","text":"cut_strategy = ClassicalCut()\nsolution_procedure = StochasticCallback()\nrun_Benders(data, solution_procedure, cut_strategy, params)","category":"page"},{"location":"examples/SCFLP/","page":"Stochastic Capacitated Facility Location Problem","title":"Stochastic Capacitated Facility Location Problem","text":"","category":"page"},{"location":"examples/SCFLP/","page":"Stochastic Capacitated Facility Location Problem","title":"Stochastic Capacitated Facility Location Problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/#API","page":"API Reference","title":"API","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [BendersDecomposition]\nOrder = [:module, :type, :function]","category":"page"},{"location":"api/#BendersDecomposition.BendersEnv","page":"API Reference","title":"BendersDecomposition.BendersEnv","text":"BendersEnv(data, master, sub, dcglp)\n\nEnvironment containing all components needed for Benders decomposition.\n\nArguments\n\ndata::AbstractData: Problem instance data\nmaster::AbstractMasterProblem: Master problem formulation\nsub::Union{AbstractSubProblem,Vector{AbstractSubProblem}}: Subproblem formulation(s)\ndcglp::Union{Nothing,DCGLP}: Optional DCGLP component for cut generation\n\n\n\n\n\n","category":"type"},{"location":"api/#BendersDecomposition.BendersEnv-Tuple{BendersDecomposition.AbstractData, BendersDecomposition.CutStrategy, BendersParams}","page":"API Reference","title":"BendersDecomposition.BendersEnv","text":"BendersEnv(data, cut_strategy, params)\n\nConstruct a BendersEnv with the given problem data and configuration.\n\nArguments\n\ndata::AbstractData: Problem instance data\ncut_strategy::CutStrategy: Strategy for generating Benders cuts\nparams::BendersParams: Algorithm parameters\n\n\n\n\n\n","category":"method"},{"location":"api/#BendersDecomposition.BendersParams","page":"API Reference","title":"BendersDecomposition.BendersParams","text":"BendersParams(time_limit, gap_tolerance, solver, master_attributes, sub_attributes, dcglp_attributes, verbose)\n\nParameters for configuring the Benders decomposition algorithm.\n\nArguments\n\ntime_limit::Float64: Maximum allowed runtime in seconds\ngap_tolerance::Float64: Optimality gap tolerance for convergence\nsolver::String: Optimization solver to use (e.g. \"CPLEX\", \"Gurobi\")\nmaster_attributes::Dict{String,Any}: Solver-specific attributes for master problem\nsub_attributes::Dict{String,Any}: Solver-specific attributes for subproblem\ndcglp_attributes::Dict{String,Any}: Solver-specific attributes for DCGLP\nverbose::Bool: Whether to print detailed progress information\n\n\n\n\n\n","category":"type"},{"location":"api/#BendersDecomposition.CFLPMasterProblem","page":"API Reference","title":"BendersDecomposition.CFLPMasterProblem","text":"CFLPMasterProblem <: AbstractCFLPMasterProblem\n\nA mutable struct representing the master problem for the Capacitated Facility Location Problem (CFLP).\n\nFields\n\nmodel::Model: The underlying JuMP optimization model\nvar::Dict: Dictionary storing the problem variables (x, t)\nobj_value::Float64: Current objective value of the master problem\nx_value::Vector{Float64}: Current values of the integer variables x\nt_value::Float64: Current value of the variable t\n\nRelated Functions\n\ncreate_master_problem(data::CFLPData, cut_strategy::Union{ClassicalCut, KnapsackCut})\n\n\n\n\n\n","category":"type"},{"location":"api/#BendersDecomposition.DCGLP","page":"API Reference","title":"BendersDecomposition.DCGLP","text":"DCGLP <: AbstractDCGLP\n\nA mutable struct representing a Disjunctive Cut Generation Linear Program (DCGLP).\n\nFields\n\nmodel::Model: The underlying JuMP optimization model\nγ_constraints::Dict{Symbol,Any}: Dictionary storing the gamma constraints of the model (γ₀, γₓ, γₜ)\nγ_values::Vector{Tuple{Float64, Vector{Float64}, Union{Float64, Vector{Float64}}}}: Vector storing gamma values\ndisjunctive_inequalities_constraints::Vector{ConstraintRef}: Vector of disjunctive inequality constraints for each index selected\ndcglp_constraints::Any: Storage for disjunctive cuts\nmaster_cuts::Any: Storage for cuts being added to the master problem\n\nThe DCGLP is used to generate cutting planes for disjunctive programming problems, particularly useful in mixed-integer programming.\n\n\n\n\n\n","category":"type"},{"location":"api/#BendersDecomposition.KnapsackCFLPSubProblem","page":"API Reference","title":"BendersDecomposition.KnapsackCFLPSubProblem","text":"KnapsackCFLPSubProblem <: AbstractCFLPSubProblem\n\nA mutable struct representing the knapsack-based subproblem formulation for the CFLP.\n\nFields\n\nmodel::Model: The underlying JuMP optimization model\nfixed_x_constraints::Vector{ConstraintRef}: Constraints fixing facility opening decisions\nother_constraints::Vector{ConstraintRef}: Other problem constraints\ndemand_constraints::Vector{ConstraintRef}: Customer demand satisfaction constraints for knapsack technique\nfacility_knapsack_info::FacilityKnapsackInfo: Information for knapsack cut generation\n\nRelated Functions\n\ncreate_sub_problem(data::CFLPData, ::KnapsackCut)\n\n\n\n\n\n","category":"type"},{"location":"api/#BendersDecomposition.KnapsackMCNDPSubProblem","page":"API Reference","title":"BendersDecomposition.KnapsackMCNDPSubProblem","text":"KnapsackMCNDPSubProblem <: AbstractMCNDPSubProblem\n\nA mutable struct representing the knapsack-based subproblem formulation for the MCNDP.\n\nFields\n\nmodel::Model: The underlying JuMP optimization model\nfixed_x_constraints::Vector{ConstraintRef}: Constraints fixing arc selection decisions\nother_constraints::Vector{ConstraintRef}: General problem constraints\ndemand_constraints::Matrix{ConstraintRef}: Flow conservation constraints for each commodity-node pair\ndata::MCNDPData: Problem instance data\nb_iv::Matrix{Float64}: Right-hand side values for flow conservation constraints\n\nRelated Functions\n\ncreate_sub_problem(data::MCNDPData, ::KnapsackCut)\n\n\n\n\n\n","category":"type"},{"location":"api/#BendersDecomposition.KnapsackSCFLPSubProblem","page":"API Reference","title":"BendersDecomposition.KnapsackSCFLPSubProblem","text":"KnapsackSCFLPSubProblem <: AbstractSCFLPSubProblem\n\nA mutable struct representing the knapsack-based subproblem formulation for the SCFLP.\n\nFields\n\nsub_problems::Vector{KnapsackCFLPSubProblem}: Vector of scenario-specific knapsack CFLP subproblems\n\nRelated Functions\n\ncreate_sub_problem(data::SCFLPData, ::KnapsackCut)\n\n\n\n\n\n","category":"type"},{"location":"api/#BendersDecomposition.KnapsackUFLPSubProblem","page":"API Reference","title":"BendersDecomposition.KnapsackUFLPSubProblem","text":"KnapsackUFLPSubProblem <: AbstractUFLPSubProblem\n\nA mutable struct representing the subproblem for the Unconstrained Facility Location Problem (UFLP) with a knapsack cut.\n\nFields\n\nsorted_cost_demands::Vector{Vector{Float64}}: Sorted cost demands for each customer\nsorted_indices::Vector{Vector{Int}}: Sorted indices for each customer\nselected_k::Dict: Dictionary storing the selected k values for each customer\n\nRelated Functions\n\ncreate_sub_problem(data::UFLPData, cut_strategy::Union{FatKnapsackCut, SlimKnapsackCut})\n\n\n\n\n\n","category":"type"},{"location":"api/#BendersDecomposition.MCNDPMasterProblem","page":"API Reference","title":"BendersDecomposition.MCNDPMasterProblem","text":"MCNDPMasterProblem <: AbstractMCNDPMasterProblem\n\nA mutable struct representing the master problem for the Multi-Commodity Network Design Problem (MCNDP).\n\nFields\n\nmodel::Model: The underlying JuMP optimization model\nvar::Dict: Dictionary storing the problem variables (x, t)\nobj_value::Float64: Current objective value of the master problem\nx_value::Vector{Float64}: Current values of the integer variables x for arc selection\nt_value::Float64: Current value of the variable t\n\nRelated Functions\n\ncreate_master_problem(data::MCNDPData, cut_strategy::Union{ClassicalCut, KnapsackCut})\n\n\n\n\n\n","category":"type"},{"location":"api/#BendersDecomposition.SCFLPMasterProblem","page":"API Reference","title":"BendersDecomposition.SCFLPMasterProblem","text":"SCFLPMasterProblem <: AbstractSCFLPMasterProblem\n\nA mutable struct representing the master problem for the Stochastic Capacitated Facility Location Problem (SCFLP).\n\nFields\n\nmodel::Model: The underlying JuMP optimization model\nvar::Dict: Dictionary storing the problem variables (x, t)\nobj_value::Float64: Current objective value of the master problem\nx_value::Vector{Float64}: Current values of the integer variables x\nt_value::Vector{Float64}: Current values of the variables t for each scenario\n\nRelated Functions\n\ncreate_master_problem(data::SCFLPData, cut_strategy::Union{ClassicalCut, KnapsackCut})\n\n\n\n\n\n","category":"type"},{"location":"api/#BendersDecomposition.SNIPMasterProblem","page":"API Reference","title":"BendersDecomposition.SNIPMasterProblem","text":"SNIPMasterProblem <: AbstractSNIPMasterProblem\n\nA mutable struct representing the master problem for the Sensor Network Installation Problem (SNIP).\n\nFields\n\nmodel::Model: The underlying JuMP optimization model\nvar::Dict: Dictionary storing the problem variables (x, t)\nobj_value::Float64: Current objective value of the master problem\nx_value::Vector{Float64}: Current values of the integer variables x\nt_value::Vector{Float64}: Current values of the variable t\n\nRelated Functions\n\ncreate_master_problem(data::SNIPData, cut_strategy::Union{ClassicalCut, KnapsackCut})\n\n\n\n\n\n","category":"type"},{"location":"api/#BendersDecomposition.StandardCFLPSubProblem","page":"API Reference","title":"BendersDecomposition.StandardCFLPSubProblem","text":"StandardCFLPSubProblem <: AbstractCFLPSubProblem\n\nA mutable struct representing the standard subproblem formulation for the Capacitated Facility Location Problem (CFLP).\n\nFields\n\nmodel::Model: The underlying JuMP optimization model\nfixed_x_constraints::Vector{ConstraintRef}: Constraints fixing x as x̂\nother_constraints::Vector{ConstraintRef}: Other problem constraints including demand satisfaction and capacity\n\nRelated Functions\n\ncreate_sub_problem(data::CFLPData, ::ClassicalCut)\n\n\n\n\n\n","category":"type"},{"location":"api/#BendersDecomposition.StandardMCNDPSubProblem","page":"API Reference","title":"BendersDecomposition.StandardMCNDPSubProblem","text":"StandardMCNDPSubProblem <: AbstractMCNDPSubProblem\n\nA mutable struct representing the standard subproblem formulation for the Multi-Commodity Network Design Problem (MCNDP).\n\nFields\n\nmodel::Model: The underlying JuMP optimization model\nfixed_x_constraints::Vector{ConstraintRef}: Constraints fixing arc selection decisions (x)\nother_constraints::Vector{ConstraintRef}: Problem constraints including flow conservation and capacity limits\n\nRelated Functions\n\ncreate_sub_problem(data::MCNDPData, ::ClassicalCut)\n\n\n\n\n\n","category":"type"},{"location":"api/#BendersDecomposition.StandardSCFLPSubProblem","page":"API Reference","title":"BendersDecomposition.StandardSCFLPSubProblem","text":"StandardSCFLPSubProblem <: AbstractSCFLPSubProblem\n\nA mutable struct representing the standard subproblem formulation for the Stochastic Capacitated Facility Location Problem (SCFLP).\n\nFields\n\nsub_problems::Vector{StandardCFLPSubProblem}: Vector of scenario-specific CFLP subproblems\n\nRelated Functions\n\ncreate_sub_problem(data::SCFLPData, ::ClassicalCut)\n\n\n\n\n\n","category":"type"},{"location":"api/#BendersDecomposition.StandardSNIPSubProblem","page":"API Reference","title":"BendersDecomposition.StandardSNIPSubProblem","text":"StandardSNIPSubProblem <: AbstractSNIPSubProblem\n\nA mutable struct representing the subproblem for the Sensor Network Installation Problem (SNIP).\n\nFields\n\nsub_problems::Vector{_StandardSNIPSubProblem}: A vector of subproblems, one for each scenario\nEach _StandardSNIPSubProblem contains:\nmodel::Model: The underlying JuMP optimization model\nfixed_x_constraints::Vector{ConstraintRef}: Constraints fixing the x variables to 0\nother_constraints::Vector{ConstraintRef}: Other constraints for the subproblem\n\nRelated Functions\n\ncreate_sub_problem(data::SNIPData, cut_strategy::ClassicalCut)\n\n\n\n\n\n","category":"type"},{"location":"api/#BendersDecomposition.StandardUFLPSubProblem","page":"API Reference","title":"BendersDecomposition.StandardUFLPSubProblem","text":"StandardUFLPSubProblem <: AbstractUFLPSubProblem\n\nA mutable struct representing the subproblem for the Unconstrained Facility Location Problem (UFLP) with a classical cut.\n\nFields\n\nmodel::Model: The underlying JuMP optimization model\nfixed_x_constraints::Vector{ConstraintRef}: Constraints fixing the x variables to 0\n\nRelated Functions\n\ncreate_sub_problem(data::UFLPData, cut_strategy::ClassicalCut)\n\n\n\n\n\n","category":"type"},{"location":"api/#BendersDecomposition.UFLPMasterProblem","page":"API Reference","title":"BendersDecomposition.UFLPMasterProblem","text":"UFLPMasterProblem <: AbstractUFLPMasterProblem\n\nA mutable struct representing the master problem for the Unconstrained Facility Location Problem (UFLP).\n\nFields\n\nmodel::Model: The underlying JuMP optimization model\nvar::Dict: Dictionary storing the problem variables (x, t)\nobj_value::Float64: Current objective value of the master problem\nx_value::Vector{Float64}: Current values of the integer variables x\nt_value::Union{Vector{Float64}, Float64}: Current values of the variable t\n\nRelated Functions\n\ncreate_master_problem(data::UFLPData, cut_strategy::CutStrategy)\n\n\n\n\n\n","category":"type"},{"location":"api/#BendersDecomposition.create_dcglp","page":"API Reference","title":"BendersDecomposition.create_dcglp","text":"create_dcglp(data::AbstractData, cut_strategy::CutStrategy)\n\nCreate the Dual Cut Generation Linear Program (DCGLP) formulation.\n\nArguments\n\ndata::AbstractData: Problem-specific data structure\ncut_strategy::CutStrategy: Strategy for generating Benders cuts\n\nReturns\n\nDCGLP structure \n\nThrows\n\nMethodError: If no implementation exists for the given data and cut strategy types\n\n\n\n\n\n","category":"function"},{"location":"api/#BendersDecomposition.create_master_problem","page":"API Reference","title":"BendersDecomposition.create_master_problem","text":"create_master_problem(data::AbstractData, cut_strategy::CutStrategy\n\n)\n\nCreate the master problem formulation for Benders decomposition.\n\nArguments\n\ndata::AbstractData: Problem-specific data structure\n`cut_strategy::CutStrategy\n\n`: Strategy for generating Benders cuts\n\nReturns\n\nA concrete subtype of AbstractMasterProblem \n\nThrows\n\nMethodError: If no implementation exists for the given data and cut strategy types\n\n\n\n\n\n","category":"function"},{"location":"api/#BendersDecomposition.create_sub_problem","page":"API Reference","title":"BendersDecomposition.create_sub_problem","text":"create_sub_problem(data::AbstractData, cut_strategy::CutStrategy)\n\nCreate the sub problem formulation for Benders decomposition.\n\nArguments\n\ndata::AbstractData: Problem-specific data structure\ncut_strategy::CutStrategy: Strategy for generating Benders cuts\n\nReturns\n\nA concrete subtype of AbstractSubProblem \n\nThrows\n\nMethodError: If no implementation exists for the given data and cut strategy types\n\n\n\n\n\n","category":"function"},{"location":"api/#BendersDecomposition.generate_cut_coefficients-Tuple{BendersDecomposition.AbstractSubProblem, Vector{Float64}, BendersDecomposition.CutStrategy}","page":"API Reference","title":"BendersDecomposition.generate_cut_coefficients","text":"generate_cut_coefficients(sub::AbstractSubProblem, x_value::Vector{Float64}, cut_strategy::CutStrategy)\n\nGenerate coefficients for Benders cuts based on subproblem solution. Must be implemented by concrete cut strategy types.\n\nArguments\n\nsub::AbstractSubProblem: Subproblem instance\nx_value::Vector{Float64}: Subproblem solution\ncut_strategy::CutStrategy: Strategy for generating cuts\n\nReturns\n\nCoefficients for Benders cuts\n\nThrows\n\nArgumentError: If the subproblem type or strategy type is not supported\n\n\n\n\n\n","category":"method"},{"location":"api/#BendersDecomposition.generate_cuts-Tuple{BendersEnv, BendersDecomposition.CutStrategy}","page":"API Reference","title":"BendersDecomposition.generate_cuts","text":"generate_cuts(env::BendersEnv, cut_strategy::CutStrategy)\n\nGenerate Benders cuts based on the current master solution.\n\nArguments\n\nenv::BendersEnv: Environment containing current solution state\ncut_strategy::CutStrategy: Strategy for generating cuts\n\nReturns\n\nCollection of generated Benders cuts\n\nThrows\n\nArgumentError: If the strategy type is not supported\n\n\n\n\n\n","category":"method"},{"location":"api/#BendersDecomposition.is_terminated-Tuple{BendersDecomposition.BendersState, BendersParams, BendersDecomposition.BendersIterationLog}","page":"API Reference","title":"BendersDecomposition.is_terminated","text":"Check termination criteria based on gap and time limit\n\n\n\n\n\n","category":"method"},{"location":"api/#BendersDecomposition.print_iteration_info-Tuple{BendersDecomposition.BendersState, BendersDecomposition.BendersIterationLog}","page":"API Reference","title":"BendersDecomposition.print_iteration_info","text":"Print iteration information if verbose mode is on\n\n\n\n\n\n","category":"method"},{"location":"api/#BendersDecomposition.run_Benders-Tuple{BendersDecomposition.AbstractData, BendersDecomposition.SolutionProcedure, BendersDecomposition.CutStrategy, BendersParams}","page":"API Reference","title":"BendersDecomposition.run_Benders","text":"run_Benders(data, loop_strategy, cut_strategy, params)\n\nExecute Benders decomposition algorithm to solve the given problem instance.\n\nArguments\n\ndata::AbstractData: Problem instance data\nloop_strategy::SolutionProcedure: Strategy for main algorithm loop (Sequential or Callback)\ncut_strategy::CutStrategy: Strategy for generating Benders cuts\nparams::BendersParams: Algorithm parameters\n\nReturns\n\nDataFrame: Solution statistics including bounds and timing information\n\n\n\n\n\n","category":"method"},{"location":"api/#BendersDecomposition.solve!-Tuple{BendersEnv, BendersDecomposition.SolutionProcedure, BendersDecomposition.CutStrategy, BendersParams}","page":"API Reference","title":"BendersDecomposition.solve!","text":"solve!(env::BendersEnv, loop::SolutionProcedure, cut_strategy::CutStrategy, params::BendersParams)\n\nMain entry point for solving a problem using Benders decomposition.\n\nArguments\n\nenv::BendersEnv: Environment containing problem data and solution state\nloop::SolutionProcedure: Solution procedure type (Sequential or Callback)\ncut_strategy::CutStrategy: Strategy for generating Benders cuts\nparams::BendersParams: Algorithm parameters and settings\n\nReturns\n\nSolution status and optimal values\n\nThrows\n\nMethodError: If the concrete type does not implement required methods\nArgumentError: If input parameters are invalid\n\n\n\n\n\n","category":"method"},{"location":"api/#BendersDecomposition.solve!-Tuple{BendersEnv, Sequential, BendersDecomposition.CutStrategy, BendersParams}","page":"API Reference","title":"BendersDecomposition.solve!","text":"Solve the Benders decomposition algorithm\n\n\n\n\n\n","category":"method"},{"location":"api/#BendersDecomposition.solve!-Tuple{BendersEnv, StochasticSequential, BendersDecomposition.CutStrategy, BendersParams}","page":"API Reference","title":"BendersDecomposition.solve!","text":"Solve the Benders decomposition algorithm\n\n\n\n\n\n","category":"method"},{"location":"api/#BendersDecomposition.solve_master!-Tuple{BendersDecomposition.AbstractMasterProblem}","page":"API Reference","title":"BendersDecomposition.solve_master!","text":"Solve the master problem\n\n\n\n\n\n","category":"method"},{"location":"api/#BendersDecomposition.solve_sub!-Tuple{BendersDecomposition.AbstractSubProblem, Vector{Float64}}","page":"API Reference","title":"BendersDecomposition.solve_sub!","text":"Solve the sub problem\n\n\n\n\n\n","category":"method"},{"location":"api/#BendersDecomposition.solve_sub!-Tuple{KnapsackUFLPSubProblem, Vector{Float64}}","page":"API Reference","title":"BendersDecomposition.solve_sub!","text":"Special case for knapsack sub problem - no need to solve\n\n\n\n\n\n","category":"method"},{"location":"tutorial/introduction/","page":"Introduction","title":"Introduction","text":"EditURL = \"introduction.jl\"","category":"page"},{"location":"tutorial/introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"tutorial/introduction/","page":"Introduction","title":"Introduction","text":"BendersDecomposition.jl is a package for solving optimization problems using Benders Decomposition.","category":"page"},{"location":"tutorial/introduction/#A-brief-introduction-to-Benders-Decomposition","page":"Introduction","title":"A brief introduction to Benders Decomposition","text":"","category":"section"},{"location":"tutorial/introduction/","page":"Introduction","title":"Introduction","text":"Now, there are a lot of papers about Benders Decomposition, and they provide a lot of formulations to describe the Benders Decomposition. However, here, we will provide a simple and intuitive explanation of the Benders Decomposition from the perspective of the Mixed-Integer Linear Programming.","category":"page"},{"location":"tutorial/introduction/","page":"Introduction","title":"Introduction","text":"The core concept of Benders decomposition is to divide the original problem into a master problem and one or more subproblems. The algorithm iteratively generates optimality and feasibility cuts, progressively refining the solution until convergence to the global optimum. Consider this problem:","category":"page"},{"location":"tutorial/introduction/","page":"Introduction","title":"Introduction","text":"beginaligned\nmin_ygeq0   c^Tx+d^Ty  \ntextst   Ax+Bygeq b \n                 D x geq h \n               x in mathbbZ^n_x\nendaligned","category":"page"},{"location":"tutorial/introduction/","page":"Introduction","title":"Introduction","text":"We can break this problem into the master problem:","category":"page"},{"location":"tutorial/introduction/","page":"Introduction","title":"Introduction","text":"beginaligned\nmin_x   c^Tx+t  \ntextst   D x geq h \n               x in mathbbZ^n_x\nendaligned","category":"page"},{"location":"tutorial/introduction/","page":"Introduction","title":"Introduction","text":"and the subproblem:","category":"page"},{"location":"tutorial/introduction/","page":"Introduction","title":"Introduction","text":"beginaligned\nmin_y   d^Ty  \ntextst   Bygeq b - A hatx \n               y geq 0\nendaligned","category":"page"},{"location":"tutorial/introduction/","page":"Introduction","title":"Introduction","text":"Here, we focus on the iterative algorithm provided in the textbook[link]. At each iteration, we solve the master problem and get the solution hatx, then input hatx into the subproblem and solve it. It's not easy to generate the cut between the x and t in the subproblem, so we consider the dual of the subproblem. The dual of the subproblem is:","category":"page"},{"location":"tutorial/introduction/","page":"Introduction","title":"Introduction","text":"beginaligned\nmax_pi   (b-Ahatx)^Tpi  \ntextst   B^Tpi leq d\nendaligned","category":"page"},{"location":"tutorial/introduction/","page":"Introduction","title":"Introduction","text":"If the dual of the subproblem is optimal, we can get the extreme point hatpi and generate the optimality cut for the master problem, like this: t geq hatpi^T (b-Ahatx). If the dual of the subproblem is infeasible, we can get the extreme ray tildepi and generate the feasibility cut for the master problem, like this: 0 geq tildepi^T (b-Ahatx).","category":"page"},{"location":"tutorial/introduction/","page":"Introduction","title":"Introduction","text":"Fianlly, we can get the problem:","category":"page"},{"location":"tutorial/introduction/","page":"Introduction","title":"Introduction","text":"beginaligned\nmin_x   c^Tx+t  \ntextst   t ge hat pi^T (b-Ax)  forall hat pi in mathcal J \n                 0 ge tilde pi^T (b-Ax)  forall tilde pi in mathcal R \n                 D x geq h \n               x in mathbbZ^n_x\nendaligned","category":"page"},{"location":"tutorial/introduction/","page":"Introduction","title":"Introduction","text":"where mathcalJ and mathcalR respectively represent the set of all extreme points and rays of the dual of the inner continuous problem:","category":"page"},{"location":"tutorial/introduction/#What-is-the-Benders-Oracle","page":"Introduction","title":"What is the Benders Oracle","text":"","category":"section"},{"location":"tutorial/introduction/","page":"Introduction","title":"Introduction","text":"Benders Oracle is a function that takes a solution to the master problem and returns a cut that is violated by the solution. Normally, the Benders Oracle is implemented by solving the subproblem. But in some cases, the subproblem is not easy to solve, researchers have proposed some other problems to receive the point from the master problem and return the cut.","category":"page"},{"location":"tutorial/introduction/","page":"Introduction","title":"Introduction","text":"If use the picture to describe the traditional Benders decomposition, it is like this:","category":"page"},{"location":"tutorial/introduction/","page":"Introduction","title":"Introduction","text":"graph LR\n    A[Master Problem] -- (x, t) --> B[Sub Problem]\n    B-- cut -->A","category":"page"},{"location":"tutorial/introduction/","page":"Introduction","title":"Introduction","text":"Similarly, if use the picture to describe the Benders decomposition with Benders Oracle, it is like this:","category":"page"},{"location":"tutorial/introduction/","page":"Introduction","title":"Introduction","text":"graph LR\n    A[Master Problem] -- (x, t) --> B[Benders Oracle]\n    B-- cut -->A","category":"page"},{"location":"tutorial/introduction/#Design-of-BendersDecomposition.jl","page":"Introduction","title":"Design of BendersDecomposition.jl","text":"","category":"section"},{"location":"tutorial/introduction/","page":"Introduction","title":"Introduction","text":"BendersDecomposition.jl is designed to be a flexible and extensible package for solving optimization problems using Benders Decomposition.","category":"page"},{"location":"tutorial/introduction/","page":"Introduction","title":"Introduction","text":"The package is designed to be modular, with each component being responsible for a specific task.","category":"page"},{"location":"tutorial/introduction/","page":"Introduction","title":"Introduction","text":"For beginners, please refer to the Beginner Tutorial.","category":"page"},{"location":"tutorial/introduction/","page":"Introduction","title":"Introduction","text":"For more advanced users, please refer to the Advanced Tutorial.","category":"page"},{"location":"tutorial/introduction/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"tutorial/introduction/","page":"Introduction","title":"Introduction","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/UFLP/","page":"Uncapacitated Facility Location Problem","title":"Uncapacitated Facility Location Problem","text":"EditURL = \"UFLP.jl\"","category":"page"},{"location":"examples/UFLP/#Uncapacitated-Facility-Location-Problem","page":"Uncapacitated Facility Location Problem","title":"Uncapacitated Facility Location Problem","text":"","category":"section"},{"location":"examples/UFLP/#Formulation","page":"Uncapacitated Facility Location Problem","title":"Formulation","text":"","category":"section"},{"location":"examples/UFLP/","page":"Uncapacitated Facility Location Problem","title":"Uncapacitated Facility Location Problem","text":"Consider this problem:","category":"page"},{"location":"examples/UFLP/","page":"Uncapacitated Facility Location Problem","title":"Uncapacitated Facility Location Problem","text":"beginaligned\nmin   sum_i in If_i x_i + sum_i in Isum_j in J c_ijd_iy_ij \ntextst   sum_i in I y_ij geq 1  forall j in J \n y_ij leq x_i  forall i in I j in J \n x in mathbb B^I y in mathbbR_+^I times J\nendaligned","category":"page"},{"location":"examples/UFLP/#Example","page":"Uncapacitated Facility Location Problem","title":"Example","text":"","category":"section"},{"location":"examples/UFLP/","page":"Uncapacitated Facility Location Problem","title":"Uncapacitated Facility Location Problem","text":"using BendersDecomposition\nusing CPLEX\nusing JuMP","category":"page"},{"location":"examples/UFLP/","page":"Uncapacitated Facility Location Problem","title":"Uncapacitated Facility Location Problem","text":"Let's solve this simple instance directly using a solver.","category":"page"},{"location":"examples/UFLP/","page":"Uncapacitated Facility Location Problem","title":"Uncapacitated Facility Location Problem","text":"data = read_uflp_benchmark_data(\"p1\"; filepath=joinpath(dirname(dirname(dirname(@__DIR__))), \"data\", \"locssall\"))\nmilp = create_milp(data)\nset_optimizer(milp.model, CPLEX.Optimizer)\nset_optimizer_attribute(milp.model, MOI.Silent(), false)\noptimize!(milp.model)","category":"page"},{"location":"examples/UFLP/","page":"Uncapacitated Facility Location Problem","title":"Uncapacitated Facility Location Problem","text":"Then, let's solve this problem using Benders decomposition.","category":"page"},{"location":"examples/UFLP/","page":"Uncapacitated Facility Location Problem","title":"Uncapacitated Facility Location Problem","text":"solver = \"CPLEX\"\nparams = BendersParams(\n    60.0, # Time limit\n    0.00001, # Tolerance\n    solver,\n    Dict(\"solver\" => solver),\n    Dict(\"solver\" => solver),\n    Dict(),\n    true # verbose\n)\ncut_strategy = ClassicalCut()\nsolution_procedure = Sequential()\nrun_Benders(data, solution_procedure, cut_strategy, params)","category":"page"},{"location":"examples/UFLP/","page":"Uncapacitated Facility Location Problem","title":"Uncapacitated Facility Location Problem","text":"If you want to use knapsack cuts, you can use the following code:","category":"page"},{"location":"examples/UFLP/","page":"Uncapacitated Facility Location Problem","title":"Uncapacitated Facility Location Problem","text":"cut_strategy = FatKnapsackCut()\nsolution_procedure = Sequential()\nrun_Benders(data, solution_procedure, cut_strategy, params)","category":"page"},{"location":"examples/UFLP/","page":"Uncapacitated Facility Location Problem","title":"Uncapacitated Facility Location Problem","text":"If you want to use callback methods, you can use the following code:","category":"page"},{"location":"examples/UFLP/","page":"Uncapacitated Facility Location Problem","title":"Uncapacitated Facility Location Problem","text":"cut_strategy = ClassicalCut()\nsolution_procedure = Callback()\nrun_Benders(data, solution_procedure, cut_strategy, params)","category":"page"},{"location":"examples/UFLP/","page":"Uncapacitated Facility Location Problem","title":"Uncapacitated Facility Location Problem","text":"","category":"page"},{"location":"examples/UFLP/","page":"Uncapacitated Facility Location Problem","title":"Uncapacitated Facility Location Problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to BendersDecomposition.jl, a package for solving optimization problems using Benders Decomposition.","category":"page"},{"location":"","page":"Home","title":"Home","text":"BendersDecomposition.jl is built on JuMP, so it supports a number of open-source and commercial solvers, making it a powerful and flexible tool for Benders Decomposition.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install BendersDecomposition.jl as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg\n\njulia> Pkg.add(\"BendersDecomposition\")","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"#Why-should-you-use-BendersDecomposition.jl?","page":"Home","title":"Why should you use BendersDecomposition.jl?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Until recently, there were no open-source, generic implementations of the Benders Decomposition algorithm available in the public domain. As a result, practitioners had to develop their own implementations in various languages and styles.","category":"page"},{"location":"","page":"Home","title":"Home","text":"BendersDecomposition.jl is designed to be a flexible and extensible package for solving optimization problems using Benders Decomposition. For the beginners, we provide a simple interface to build the model and solve the problem. For the researchers and industry practitioners, we provide the BendersOracle interface to customize the modeling, solving and cutting process. In general, the design philosophy of BendersDecomposition.jl prioritizes flexibility and efficiency, aiming to deliver a feature-rich and user-friendly experience. ","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Learn the basics of JuMP and Julia in the JuMP documentation\nFollow the tutorials in this manual","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you need help, please open a GitHub issue.","category":"page"},{"location":"#Citing-BendersDecomposition.jl","page":"Home","title":"Citing BendersDecomposition.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use BendersDecomposition.jl in your work, please cite the following paper:","category":"page"}]
}
