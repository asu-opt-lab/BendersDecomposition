<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Advanced Tutorial · BendersDecomposition.jl</title><meta name="title" content="Advanced Tutorial · BendersDecomposition.jl"/><meta property="og:title" content="Advanced Tutorial · BendersDecomposition.jl"/><meta property="twitter:title" content="Advanced Tutorial · BendersDecomposition.jl"/><meta name="description" content="Documentation for BendersDecomposition.jl."/><meta property="og:description" content="Documentation for BendersDecomposition.jl."/><meta property="twitter:description" content="Documentation for BendersDecomposition.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">BendersDecomposition.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../introduction/">Introduction</a></li><li><a class="tocitem" href="../beginner/">Beginner Tutorial</a></li><li class="is-active"><a class="tocitem" href>Advanced Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Key-Concepts"><span>Key Concepts</span></a></li><li><a class="tocitem" href="#Modeling"><span>Modeling</span></a></li><li><a class="tocitem" href="#Environment"><span>Environment</span></a></li><li><a class="tocitem" href="#Solution-Procedure"><span>Solution Procedure</span></a></li><li><a class="tocitem" href="#Cut-Strategy"><span>Cut Strategy</span></a></li></ul></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/intro/">Introduction</a></li><li><a class="tocitem" href="../../examples/CFLP/">Capacitated Facility Location Problem</a></li><li><a class="tocitem" href="../../examples/UFLP/">Uncapacitated Facility Location Problem</a></li><li><a class="tocitem" href="../../examples/MCNDP/">Multi-Commodity Network Design Problem</a></li><li><a class="tocitem" href="../../examples/SCFLP/">Stochastic Capacitated Facility Location Problem</a></li><li><a class="tocitem" href="../../examples/SNIP/">Stochastic Network Interdiction Problem</a></li></ul></li><li><a class="tocitem" href="../../api/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Advanced Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Advanced Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ASUKaiwenFang/BendersDecomposition" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ASUKaiwenFang/BendersDecomposition/blob/main/docs/src/tutorial/advanced.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Advanced-Tutorial"><a class="docs-heading-anchor" href="#Advanced-Tutorial">Advanced Tutorial</a><a id="Advanced-Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-Tutorial" title="Permalink"></a></h1><p>For the researchers and industry practitioners, they may need to customize the Benders Decomposition algorithm to solve their own problems. We provide the <code>BendersOracle</code> interface to allow users to customize the modeling, solving and cutting process.</p><h2 id="Key-Concepts"><a class="docs-heading-anchor" href="#Key-Concepts">Key Concepts</a><a id="Key-Concepts-1"></a><a class="docs-heading-anchor-permalink" href="#Key-Concepts" title="Permalink"></a></h2><p><code>AbstractData</code>: The data structure that stores the problem data. For large-scale problems, it is recommended to use the <code>AbstractData</code> interface to store the problem data. Then the user can use the data to build the model.</p><p><code>SolutionProcedure</code>: Itertively or callback function to process the solution.</p><p><code>CutStrategy</code>: The strategy to generate the cuts, such as classical Benders cut, unified Benders cut, etc.</p><p><code>AbstractMasterProblem</code>: The abstract type for the master problem.</p><p><code>AbstractSubProblem</code>: The abstract type for the subproblem.</p><h2 id="Modeling"><a class="docs-heading-anchor" href="#Modeling">Modeling</a><a id="Modeling-1"></a><a class="docs-heading-anchor-permalink" href="#Modeling" title="Permalink"></a></h2><p>Unlike algebraic algorithms, Benders decomposition is typically used for large-scale problems. In this approach, researchers do not rely on abstract matrix representations to compute key elements in the solving process. Instead, researchers usually explicitly formulate both the master problem and the subproblem. The partitioning of variables and constraints can vary significantly depending on the application.</p><p>Then the next question is how to build the model. Which information should we use to build the model? Our answer is <code>AbstractData</code> and <code>CutStrategy</code>. For different applications, the <code>AbstractData</code> is different. For the same application, the <code>CutStrategy</code> can be different. We only need to provide the <code>AbstractData</code> and <code>CutStrategy</code> to build the model. So we have two functions to build the model:</p><ul><li>Use <code>create_master_problem(data::AbstractData, cut_strategy::CutStrategy)</code> to build <code>master_problem &lt;: AbstractMasterProblem</code>.</li><li>Use <code>create_sub_problem(data::AbstractData, cut_strategy::CutStrategy)</code> to build <code>sub_problem &lt;: AbstractSubProblem</code>.</li></ul><p>We provide a general standard structure for master problem and subproblem for different applications. General structures:</p><pre><code class="language-julia hljs">struct GeneralMasterProblem &lt;: AbstractMasterProblem
    model::Model # JuMP model
    var::Dict # variable dictionary
    obj_value::Float64 # objective value
    x_value::Vector{Float64} # integer variables
    t_value::Union{Float64,Vector{Float64}} # continuous variables
end</code></pre><p>and</p><pre><code class="language-julia hljs">struct GeneralSubProblem &lt;: AbstractSubProblem
    model::Model # JuMP model
    fixed_x_constraints::Vector{ConstraintRef} # fixed integer variables constraints
    other_constraints::Vector{ConstraintRef} # other constraints
end</code></pre><p>But if user want to use their own unique model, they can define their own structures and multiple dispatch the <code>create_master_problem</code> and <code>create_sub_problem</code> function.</p><p>For example, the fat knapsack cut method proposed by Fischetti in uncapacitated facility location problem, we don&#39;t need to build a traditional subproblem. We define a new structure storing necessary information to represent the subproblem:</p><pre><code class="language-julia hljs">mutable struct KnapsackUFLPSubProblem &lt;: AbstractUFLPSubProblem
    sorted_cost_demands::Vector{Vector{Float64}}
    sorted_indices::Vector{Vector{Int}}
    selected_k::Dict
end</code></pre><p>If you want to use the Disjunctive Benders Cuts we proposed in our paper, you can use <code>create_dcglp(data::AbstractData, cut_strategy::CutStrategy)</code> to build <code>dcglp &lt;: AbstractDCGLP</code>.</p><h2 id="Environment"><a class="docs-heading-anchor" href="#Environment">Environment</a><a id="Environment-1"></a><a class="docs-heading-anchor-permalink" href="#Environment" title="Permalink"></a></h2><p>Here we introduce a new concept: <code>Environment</code>, borrowed from Reinforcement Learning. The <code>BendersEnv</code> is a structure that stores the modeling information:</p><pre><code class="language-julia hljs">mutable struct BendersEnv
    master::AbstractMasterProblem
    sub::Union{AbstractSubProblem, Vector{AbstractSubProblem}} # for deterministic problems, sub is a single subproblem; for stochastic problems, sub is a vector of subproblems
    dcglp::Union{Nothing, DCGLP}  # Optional component
end</code></pre><h2 id="Solution-Procedure"><a class="docs-heading-anchor" href="#Solution-Procedure">Solution Procedure</a><a id="Solution-Procedure-1"></a><a class="docs-heading-anchor-permalink" href="#Solution-Procedure" title="Permalink"></a></h2><p>In textbooks, Benders decomposition is typically presented as an iterative algorithm. However, in research applications, the Branch-and-Cut method is often used to obtain the final results. In this approach, researchers leverage callback methods to incorporate lazy constraints, user cuts and heuristic methods, providing flexibility in implementation. This allows for various strategies to enhance the efficiency of the decomposition process.</p><p>In this package, we provide <code>Sequential()</code>, <code>Callback()</code>, <code>StochasticSequential()</code>, <code>StochasticCallback()</code> to solve the problem.</p><p>The corresponding function is <code>solve!(env::BendersEnv, solution_procedure::SolutionProcedure, params::Params)</code>.</p><p>For example, the iterative solution procedure is:</p><pre><code class="language-julia hljs">function solve!(env::BendersEnv, ::Sequential, cut_strategy::CutStrategy, params::BendersParams)
    log = BendersIterationLog()
    state = BendersState()

    while true
        state.iteration += 1

        # Solve master problem
        master_time = @elapsed begin
            solve_master!(env.master)
            state.LB = env.master.obj_value
        end
        log.master_time += master_time

        # Solve sub problem
        sub_time = @elapsed begin
            solve_sub!(env.sub, env.master.x_value)
            cuts, sub_obj_val = generate_cuts(env, cut_strategy)
            update_upper_bound_and_gap!(state, env, sub_obj_val)
        end
        log.sub_time += sub_time

        # Update state and record information
        record_iteration!(log, state)

        params.verbose &amp;&amp; print_iteration_info(state, log)

        # Check termination criteria
        is_terminated(state, params, log) &amp;&amp; break

        # Generate and add cuts
        for cut in cuts
            @constraint(env.master.model, 0 &gt;= cut)
        end
    end
end</code></pre><p>The callback method:</p><pre><code class="language-julia hljs">function solve!(env::BendersEnv, ::Callback, cut_strategy::CutStrategy, params::BendersParams)

    start_time = time()
    function lazy_callback(cb_data)
        status = JuMP.callback_node_status(cb_data, env.master.model)
        if status == MOI.CALLBACK_NODE_STATUS_INTEGER
            env.master.x_value = JuMP.callback_value.(cb_data, env.master.var[:x])
            env.master.t_value = JuMP.callback_value.(cb_data, env.master.var[:t])

            solve_sub!(env.sub, env.master.x_value)
            cuts, sub_obj_value = generate_cuts(env, cut_strategy)
            add_cuts!(env, cuts, sub_obj_value, cb_data)
        end
    end

    function user_cut_callback(cb_data)
        ... # user cut callback
    end

    # Use the closure callbacks
    set_attribute(env.master.model, MOI.LazyConstraintCallback(), lazy_callback)
    set_attribute(env.master.model, MOI.UserCutCallback(), user_cut_callback)
    MOI.set(env.master.model, MOI.RelativeGapTolerance(), params.gap_tolerance)
    set_time_limit_sec(env.master.model, params.time_limit)
    set_optimizer_attribute(env.master.model, MOI.Silent(), false)
    JuMP.optimize!(env.master.model)
end</code></pre><p>The user can customize the solution procedure by defining a new <code>SolutionProcedure</code> and multiple dispatch the <code>solve!</code> function.</p><h2 id="Cut-Strategy"><a class="docs-heading-anchor" href="#Cut-Strategy">Cut Strategy</a><a id="Cut-Strategy-1"></a><a class="docs-heading-anchor-permalink" href="#Cut-Strategy" title="Permalink"></a></h2><p>The cut strategy is the key to the Benders decomposition algorithm. The cut strategy determines how to generate the cuts.</p><p>We provide some general cut strategies for different applications, such as classical cut, unified cut, disjunctive cut, etc.</p><p>The key function is <code>generate_cut(env::BendersEnv, cut_strategy::CutStrategy)</code>, which generates the cuts and add them to the model.</p><p>For example, the classical cut is:</p><pre><code class="language-julia hljs">function generate_cuts(env::BendersEnv, ::ClassicalCut)
    (coefficients_t, coefficients_x, constant_term), sub_obj_val = generate_cut_coefficients(env.sub, env.master.x_value, ClassicalCut())

    cut = @expression(env.master.model,
        constant_term + dot(coefficients_x, env.master.var[:x]) + coefficients_t * env.master.var[:t])

    return cut, sub_obj_val
end</code></pre><p>If you want to use the fat knapsack cut:</p><pre><code class="language-julia hljs">function generate_cuts(env::BendersEnv, cut_strategy::Union{FatKnapsackCut, SlimKnapsackCut})

    # return vector
    critical_pairs, obj_values = generate_cut_coefficients(env.sub, env.master.x_value, cut_strategy)

    cuts = Vector{Any}(undef, length(critical_pairs))
    for (index, critical_item) in critical_pairs
        cuts[index] = build_cut(env.master, env.sub, (index, critical_item), cut_strategy)
    end

    return cuts, obj_values
end</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../beginner/">« Beginner Tutorial</a><a class="docs-footer-nextpage" href="../../examples/intro/">Introduction »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Tuesday 4 February 2025 15:02">Tuesday 4 February 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
